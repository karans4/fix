#!/usr/bin/env python3
"""fix -- AI-powered command fixer.

Usage:
    fix it                              Fix the last failed command (99% of the time)
    fix <command>                       Run command; if it fails, diagnose and fix

Options:
    fix --safe <command>                Sandboxed: overlay + rollback on failure
    fix --explain <command>             Explain the error without fixing
    fix --dry-run <command>             Show fix without executing
    fix --verify=human <command>        Human judges the result
    fix --verify="contains 'X'" <cmd>   Stdout must contain X
    fix --verify="CMD" <command>        Run CMD as verification
    fix --local <command>               Force Ollama backend
    fix -m MODEL <command>              Use a specific model
    fix --root DIR <command>            Jail agent investigation to DIR
    fix -y <command>                    Auto-apply without confirmation

Config:
    ~/.fix/config.py                    Global config (Python)
    .fix.py                             Project config (overrides global)

    Config vars: model, ollama_model, ollama_url, safe_mode, verify, root,
                 openai_api_url, openai_model, backend, hidden_paths,
                 bounty, judge

Shell:
    eval "$(fix shell)"                 Add to .bashrc/.zshrc/config.fish (enables fix !!)

Project:
    fix init                            Create a .fix.py config for this project
"""

import subprocess, sys, os, json, time, platform, shutil, re

# --- Config ---
CONFIG_DIR = os.path.expanduser("~/.fix")
MAX_FIX_ATTEMPTS = 3
MAX_INVESTIGATE_ROUNDS = 5
INVESTIGATE_TIMEOUT = 5
HUMAN_VERIFY_TIMEOUT = 60

# Claude API defaults
CLAUDE_API_URL = "https://api.anthropic.com/v1/messages"
CLAUDE_MODEL = "claude-haiku-4-5-20251001"

# Ollama defaults
OLLAMA_URL = "http://localhost:11434/api/generate"
OLLAMA_MODEL = "qwen2.5-coder:1.5b"

# --- Investigation ---
# Regex to detect investigation requests in LLM output
INVESTIGATE_RE = re.compile(r'^INVESTIGATE:\s*(.+)$', re.MULTILINE)

# Whitelist of allowed command prefixes for investigation
INVESTIGATE_WHITELIST = {
    # File inspection
    "cat", "head", "tail", "less", "file", "wc", "stat", "md5sum", "sha256sum",
    # Directory listing
    "ls", "find", "tree", "du",
    # Search
    "grep", "rg", "ag", "awk", "sed",
    # Versions/info
    "which", "whereis", "type", "command", "uname", "arch", "lsb_release", "hostnamectl",
    # Package queries
    "dpkg", "apt", "apt-cache", "apt-file", "apt-list", "rpm", "pacman",
    "pip", "pip3", "npm", "gem", "cargo", "rustc",
    # Runtime versions
    "python3", "python", "node", "gcc", "g++", "make", "cmake", "java", "go", "ruby",
    "clang", "clang++", "ld", "as", "nasm",
    # Environment
    "env", "printenv", "echo", "id", "whoami", "pwd", "hostname",
    # System info
    "lsmod", "lscpu", "free", "df", "mount", "ip", "ss",
    # Logs (read-only)
    "journalctl", "dmesg",
    # Misc
    "readlink", "realpath", "basename", "dirname", "diff", "cmp",
    "strings", "nm", "ldd", "objdump", "pkg-config", "test",
}

# Characters that indicate write operations
DANGEROUS_PATTERNS = {">", ">>", "tee ", "tee\t", "| tee"}


def _extract_paths(cmd):
    """Extract file/directory path arguments from a shell command."""
    import shlex
    try:
        parts = shlex.split(cmd)
    except ValueError:
        parts = cmd.split()
    paths = []
    for p in parts[1:]:
        if p.startswith("-"):
            continue
        # Looks like a path if it contains / or starts with .
        if "/" in p or p.startswith("."):
            paths.append(p)
    return paths


def validate_investigate_command(cmd, root=None):
    """Check if a command is safe for investigation (read-only whitelist + root jail)."""
    cmd = cmd.strip()
    if not cmd:
        return False, "empty command"

    # Block write redirections
    for pat in DANGEROUS_PATTERNS:
        if pat in cmd:
            return False, f"blocked: contains '{pat}' (write operation)"

    # Extract the first word (the actual command)
    first_word = cmd.split()[0]
    # Strip path prefix: /usr/bin/cat -> cat
    first_word = os.path.basename(first_word)

    if first_word not in INVESTIGATE_WHITELIST:
        return False, f"'{first_word}' not in investigation whitelist"

    # Root jail: check that all path arguments resolve inside root
    if root:
        root_abs = os.path.realpath(root)
        for p in _extract_paths(cmd):
            # Resolve relative to root (since cwd will be root)
            if os.path.isabs(p):
                resolved = os.path.realpath(p)
            else:
                resolved = os.path.realpath(os.path.join(root_abs, p))
            if not resolved.startswith(root_abs + "/") and resolved != root_abs:
                return False, f"path '{p}' is outside root ({root_abs})"

    return True, ""


def run_investigate_command(cmd, root=None, safe_mode=False, sandbox=None):
    """Run a read-only investigation command. Returns output string."""
    ok, reason = validate_investigate_command(cmd, root=root)
    if not ok:
        return f"[BLOCKED] {reason}"

    try:
        if safe_mode and sandbox:
            result = sandbox.run_in_sandbox(cmd, network=False)
            out = (result.stdout + result.stderr)[:2000]
        else:
            result = subprocess.run(
                cmd, shell=True, capture_output=True, text=True,
                timeout=INVESTIGATE_TIMEOUT,
                cwd=root,
            )
            out = (result.stdout + result.stderr)[:2000]
        return out if out.strip() else "(no output)"
    except subprocess.TimeoutExpired:
        return "[TIMEOUT] command exceeded 5s limit"
    except Exception as e:
        return f"[ERROR] {e}"


# --- Colors ---
C_RESET = "\033[0m"
C_RED = "\033[31m"
C_GREEN = "\033[32m"
C_YELLOW = "\033[33m"
C_BLUE = "\033[34m"
C_CYAN = "\033[36m"
C_DIM = "\033[2m"
C_BOLD = "\033[1m"
C_ITALIC = "\033[3m"

if not sys.stderr.isatty():
    C_RESET = C_RED = C_GREEN = C_YELLOW = C_BLUE = C_CYAN = C_DIM = C_BOLD = C_ITALIC = ""


def status(icon, msg):
    print(f"  {icon}  {msg}", file=sys.stderr)


# --- Config (Python) ---

DEFAULTS = {
    "backend": "auto",
    "model": CLAUDE_MODEL,
    "safe_mode": False,
    "ollama_model": OLLAMA_MODEL,
    "ollama_url": OLLAMA_URL,
    "hidden_paths": ["~/.ssh", "~/.gnupg", "~/.aws", "~/.fix",
                     "~/.config/gh", "~/.netrc", "~/.azure", "~/.kube",
                     "~/.docker", "~/.gitconfig", "~/.bash_history",
                     "~/.python_history"],
    "openai_api_url": "",
    "openai_model": "",
    "root": None,       # restrict agent investigation to this directory
    "verify": None,     # default verification command for this project
    "agent": None,      # custom agent function: f(contract) -> response dict
    "bounty": None,     # optional escrow bounty: "0.01 USDC", "100 sats", etc.
    "judge": None,      # optional dispute judge: f(contract, outcome) -> verdict dict
}


def _exec_config(path):
    """Execute a Python config file and return its namespace as a dict."""
    ns = {"__builtins__": __builtins__}
    try:
        with open(path) as f:
            exec(f.read(), ns)
    except FileNotFoundError:
        return {}
    except Exception as e:
        print(f"  {C_RED}\u2717{C_RESET}  Error in {path}: {e}", file=sys.stderr)
        return {}
    # Extract user-defined names (skip dunders and modules)
    return {k: v for k, v in ns.items() if not k.startswith("_")}


def _find_project_config():
    """Walk up from CWD to find .fix.py (stops at git root or /)."""
    d = os.getcwd()
    while True:
        candidate = os.path.join(d, ".fix.py")
        if os.path.isfile(candidate):
            return candidate
        # Stop at git root or filesystem root
        if os.path.isdir(os.path.join(d, ".git")):
            break
        parent = os.path.dirname(d)
        if parent == d:
            break
        d = parent
    return None


def load_config():
    """Load config: defaults <- ~/.fix/config.py <- .fix.py (project-local).

    Config files are Python. Set variables, define functions.
    A `def agent(contract)` becomes the custom backend.
    A `verify = "pytest"` sets the default verification command.
    """
    cfg = dict(DEFAULTS)

    # Global config
    global_path = os.path.join(CONFIG_DIR, "config.py")
    global_cfg = _exec_config(global_path)
    cfg.update(global_cfg)

    # Project-local config (overrides global)
    project_path = _find_project_config()
    if project_path:
        project_cfg = _exec_config(project_path)
        cfg.update(project_cfg)
        cfg["_project_config"] = project_path

    return cfg


def generate_config():
    """Generate a .fix.py in CWD with sensible defaults for the project type."""
    lines = ['# .fix.py -- project config for fix (https://github.com/karans4/fix)', '']

    # Detect project type
    cwd = os.getcwd()
    if os.path.exists(os.path.join(cwd, "pyproject.toml")) or os.path.exists(os.path.join(cwd, "setup.py")):
        lines.append('# Python project detected')
        if os.path.isdir(os.path.join(cwd, "tests")):
            lines.append('verify = "python3 -m pytest tests/"')
        else:
            lines.append('# verify = "python3 -m pytest"')
    elif os.path.exists(os.path.join(cwd, "package.json")):
        lines.append('# Node.js project detected')
        lines.append('verify = "npm test"')
    elif os.path.exists(os.path.join(cwd, "Cargo.toml")):
        lines.append('# Rust project detected')
        lines.append('verify = "cargo test"')
    elif os.path.exists(os.path.join(cwd, "go.mod")):
        lines.append('# Go project detected')
        lines.append('verify = "go test ./..."')
    elif os.path.exists(os.path.join(cwd, "Makefile")):
        lines.append('# Makefile detected')
        lines.append('verify = "make test"')
    else:
        lines.append('# verify = "make test"  # default verification command')

    lines += [
        '',
        '# safe_mode = True  # always use sandbox',
        '# backend = "local"  # force ollama',
        '',
        '# Custom agent -- receives contract dict, returns fix dict.',
        '# Uncomment to use your own backend instead of the built-in LLM calls.',
        '#',
        '# def agent(contract):',
        '#     """',
        '#     contract = {',
        '#         "task": {"command": "...", "error": "..."},',
        '#         "environment": {"os": "...", ...},',
        '#         "verification": {"method": "...", "criterion": "..."},',
        '#         "terms": {"sandbox": bool, ...}',
        '#     }',
        '#     Return: {"accepted": True, "fix": "...", "explanation": "...", "retry": True}',
        '#     """',
        '#     import httpx',
        '#     return httpx.post("https://my-service/fix", json=contract).json()',
        '',
    ]

    with open(".fix.py", "w") as f:
        f.write("\n".join(lines) + "\n")
    print(f"Created .fix.py ({os.path.basename(os.getcwd())})")
    return


# fc -ln -2 works for bash/ksh/dash (POSIX). head -1 grabs the one before "fix it" itself.
_POSIX_HOOK = """\
fix() {
  if [ "$1" = "it" ] || [ "$1" = "!!" ]; then
    FIX_LAST_COMMAND="$(fc -ln -2 | head -1 | sed 's/^[[:space:]]*//')" command fix "$@"
  else
    command fix "$@"
  fi
}"""

SHELL_HOOKS = {
    "bash": _POSIX_HOOK,
    "ksh":  _POSIX_HOOK,
    "dash": _POSIX_HOOK,
    "sh":   _POSIX_HOOK,
    "zsh": """\
fix() {
  if [[ "$1" == "it" || "$1" == "!!" ]]; then
    FIX_LAST_COMMAND="${history[$((HISTCMD-1))]}" command fix "$@"
  else
    command fix "$@"
  fi
}""",
    "fish": """\
function fix --wraps=fix --description 'AI command fixer'
    if test (count $argv) -gt 0; and test "$argv[1]" = "it" -o "$argv[1]" = "!!"
        set -lx FIX_LAST_COMMAND (builtin history search --max 1 --prefix "")
        command fix $argv
    else
        command fix $argv
    end
end""",
}

# Shell name -> (rc file path, eval line to append)
_RC_FILES = {
    "bash": ("~/.bashrc",                      'eval "$(fix shell)"'),
    "zsh":  ("~/.zshrc",                        'eval "$(fix shell)"'),
    "ksh":  ("~/.kshrc",                        'eval "$(fix shell)"'),
    "dash": ("~/.profile",                      'eval "$(fix shell)"'),
    "sh":   ("~/.profile",                      'eval "$(fix shell)"'),
    "fish": ("~/.config/fish/config.fish",       'fix shell fish | source'),
}


def _detect_shell():
    """Detect the actual running shell, not just $SHELL (login shell).

    1. Check parent process name via /proc/$PPID/comm (Linux)
    2. Fall back to ps(1)
    3. Fall back to $SHELL env var
    Returns the short name: bash, zsh, fish, ksh, dash, etc.
    """
    ppid = os.getppid()

    # Try /proc (Linux, fast)
    try:
        with open(f"/proc/{ppid}/comm") as f:
            name = f.read().strip()
        if name:
            return name
    except (OSError, IOError):
        pass

    # Try ps (macOS, BSDs)
    try:
        result = subprocess.run(["ps", "-p", str(ppid), "-o", "comm="],
                                capture_output=True, text=True, timeout=2)
        if result.returncode == 0:
            name = os.path.basename(result.stdout.strip()).lstrip("-")
            if name:
                return name
    except Exception:
        pass

    # Fall back to $SHELL
    return os.path.basename(os.environ.get("SHELL", "bash"))


def _rc_path(name):
    """Return the rc file path for a shell."""
    path, _ = _RC_FILES.get(name, _RC_FILES["bash"])
    return os.path.expanduser(path)


def _rc_eval_line(name):
    """Return the eval line to add to the rc file."""
    _, line = _RC_FILES.get(name, _RC_FILES["bash"])
    return line


def shell_hook():
    """Print shell integration code for eval."""
    # Allow explicit: fix shell bash / fix shell zsh / fix shell fish
    if len(sys.argv) > 2 and sys.argv[2] != "--install":
        name = sys.argv[2]
    else:
        name = _detect_shell()

    if name in SHELL_HOOKS:
        print(SHELL_HOOKS[name])
    else:
        # Unknown shell — explain what's needed
        print(f"# fix: no built-in hook for '{name}'.", file=sys.stderr)
        print(f"# Set FIX_LAST_COMMAND to the previous command before calling fix.", file=sys.stderr)
        print(f"# Example (POSIX-like shells):", file=sys.stderr)
        print(f"#   FIX_LAST_COMMAND=\"your_cmd\" fix it", file=sys.stderr)
        print(f"#", file=sys.stderr)
        print(f"# If '{name}' supports fc(1), the bash hook will likely work:", file=sys.stderr)
        print(f"#   eval \"$(fix shell bash)\"", file=sys.stderr)
        sys.exit(1)


def shell_install():
    """Auto-append shell hook to the user's rc file. Returns True if installed."""
    name = _detect_shell()

    if name not in SHELL_HOOKS:
        print(f"  {C_DIM}Unknown shell: {name}{C_RESET}", file=sys.stderr)
        print(f"  {C_DIM}If it supports fc(1), try: eval \"$(fix shell bash)\"{C_RESET}", file=sys.stderr)
        print(f"  {C_DIM}Otherwise, set FIX_LAST_COMMAND before calling fix it.{C_RESET}", file=sys.stderr)
        return False

    rc = _rc_path(name)
    eval_line = _rc_eval_line(name)

    # Check if already installed
    if os.path.exists(rc):
        with open(rc) as f:
            contents = f.read()
        if 'fix shell' in contents:
            return True  # already there

    try:
        response = input(f"  Add shell hook to {rc}? [Y/n] ").strip().lower()
    except (EOFError, KeyboardInterrupt):
        return False
    if response and response != "y":
        return False

    os.makedirs(os.path.dirname(rc) or ".", exist_ok=True)
    with open(rc, "a") as f:
        f.write(f"\n# fix shell integration (https://github.com/karans4/fix)\n{eval_line}\n")
    print(f"  Added to {rc}. Restart your shell or: source {rc}")
    return True


# --- Environment Fingerprinting ---

def get_env_fingerprint():
    info = {
        "os": platform.system(),
        "release": platform.release(),
        "machine": platform.machine(),
        "distro": "",
        "shell": os.environ.get("SHELL", ""),
        "python": platform.python_version(),
    }
    try:
        with open("/etc/os-release") as f:
            for line in f:
                if line.startswith("PRETTY_NAME="):
                    info["distro"] = line.split("=", 1)[1].strip().strip('"')
                    break
    except FileNotFoundError:
        pass

    pms = [pm for pm in ("apt", "dnf", "pacman", "brew", "pip", "npm", "cargo")
           if shutil.which(pm)]
    info["package_managers"] = pms
    return info


# --- Verification ---

def _input_with_timeout(prompt, timeout):
    """Like input() but returns None after timeout seconds."""
    import select
    sys.stderr.write(prompt)
    sys.stderr.flush()
    ready, _, _ = select.select([sys.stdin], [], [], timeout)
    if ready:
        return sys.stdin.readline().rstrip("\n")
    print(file=sys.stderr)  # newline after the unanswered prompt
    return None


class Verifier:
    """Verification predicate: did the fix work?"""

    def __init__(self, spec, original_cmd):
        self.spec = spec
        self.original_cmd = original_cmd

    def verify(self, fix_result):
        """Returns (success: bool, explanation: str)"""
        if self.spec is None:
            # Default: re-run original, exit 0 = success
            return self._verify_rerun()
        if self.spec == "human":
            return self._verify_human(fix_result)
        if self.spec.startswith("contains "):
            return self._verify_contains(fix_result)
        if self.spec.startswith("not contains "):
            return self._verify_not_contains(fix_result)
        # Treat as custom verification command
        return self._verify_command(self.spec)

    def _verify_rerun(self):
        proc = subprocess.run(self.original_cmd, shell=True, capture_output=True, text=True)
        if proc.returncode == 0:
            return True, "Command succeeded (exit 0)"
        return False, f"Command failed (exit {proc.returncode}): {proc.stderr[:200]}"

    def _verify_human(self, fix_result):
        print(f"\n{C_BLUE}--- Fix Result ---{C_RESET}", file=sys.stderr)
        # Re-run original to show current output
        proc = subprocess.run(self.original_cmd, shell=True, capture_output=True, text=True)
        if proc.stdout:
            sys.stdout.write(proc.stdout)
        if proc.stderr:
            sys.stderr.write(proc.stderr)
        print(f"{C_BLUE}--- End Result ---{C_RESET}\n", file=sys.stderr)
        try:
            answer = _input_with_timeout(
                f"  ?  Did this fix your problem? [Y/n] ({HUMAN_VERIFY_TIMEOUT}s) ",
                HUMAN_VERIFY_TIMEOUT
            )
            if answer is None:
                return False, f"Human did not respond within {HUMAN_VERIFY_TIMEOUT}s (backed out)"
            if answer.strip().lower() == "n":
                return False, "Human rejected the result"
            return True, "Human approved the result"
        except (EOFError, KeyboardInterrupt):
            return False, "No human input"

    def _verify_contains(self, fix_result):
        # Extract expected string from spec: contains 'X' or contains "X"
        match = re.match(r"contains\s+['\"](.+?)['\"]", self.spec)
        if not match:
            return False, f"Bad verify spec: {self.spec}"
        expected = match.group(1)
        proc = subprocess.run(self.original_cmd, shell=True, capture_output=True, text=True)
        if expected in proc.stdout:
            return True, f"stdout contains '{expected}'"
        return False, f"stdout does not contain '{expected}'"

    def _verify_not_contains(self, fix_result):
        match = re.match(r"not contains\s+['\"](.+?)['\"]", self.spec)
        if not match:
            return False, f"Bad verify spec: {self.spec}"
        forbidden = match.group(1)
        proc = subprocess.run(self.original_cmd, shell=True, capture_output=True, text=True)
        if forbidden in proc.stderr or forbidden in proc.stdout:
            return False, f"Output contains '{forbidden}'"
        return True, f"Output does not contain '{forbidden}'"

    def _verify_command(self, cmd):
        proc = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        if proc.returncode == 0:
            return True, f"Verification command passed"
        return False, f"Verification command failed (exit {proc.returncode})"


class SandboxVerifier(Verifier):
    """Runs verification inside the sandbox."""

    def __init__(self, spec, original_cmd, sandbox):
        super().__init__(spec, original_cmd)
        self.sandbox = sandbox

    def _verify_rerun(self):
        result = self.sandbox.run_in_sandbox(self.original_cmd, network=True)
        if result.returncode == 0:
            return True, "Command succeeded in sandbox (exit 0)"
        return False, f"Command failed in sandbox (exit {result.returncode})"

    def _verify_command(self, cmd):
        result = self.sandbox.run_in_sandbox(cmd, network=True)
        if result.returncode == 0:
            return True, "Verification passed in sandbox"
        return False, f"Verification failed in sandbox (exit {result.returncode})"


# --- LLM Backends ---

def call_claude(prompt, api_key, model=None, api_url=None):
    import httpx
    resp = httpx.post(
        api_url or CLAUDE_API_URL,
        headers={
            "x-api-key": api_key,
            "anthropic-version": "2023-06-01",
            "content-type": "application/json",
        },
        json={
            "model": model or CLAUDE_MODEL,
            "max_tokens": 1024,
            "messages": [{"role": "user", "content": prompt}],
        },
        timeout=30,
    )
    if resp.status_code != 200:
        raise RuntimeError(f"Claude API error {resp.status_code}: {resp.text[:200]}")
    return resp.json()["content"][0]["text"]


def call_openai(prompt, api_key, model, api_url):
    """Call any OpenAI-compatible API (OpenAI, Together, Groq, etc.)."""
    import httpx
    resp = httpx.post(
        api_url.rstrip("/") + "/chat/completions",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
        },
        json={
            "model": model,
            "max_tokens": 1024,
            "messages": [{"role": "user", "content": prompt}],
        },
        timeout=30,
    )
    if resp.status_code != 200:
        raise RuntimeError(f"OpenAI-compatible API error {resp.status_code}: {resp.text[:200]}")
    return resp.json()["choices"][0]["message"]["content"]


def call_ollama(prompt, model=None, url=None):
    import httpx
    resp = httpx.post(
        url or OLLAMA_URL,
        json={"model": model or OLLAMA_MODEL, "prompt": prompt, "stream": False},
        timeout=60,
    )
    if resp.status_code != 200:
        raise RuntimeError(f"Ollama error {resp.status_code}: {resp.text[:200]}")
    return resp.json()["response"]


def ollama_available(url=None):
    try:
        import httpx
        base = (url or OLLAMA_URL).split("/api/")[0]
        resp = httpx.get(base + "/api/tags", timeout=2)
        return resp.status_code == 200
    except Exception:
        return False


def get_api_key(key_type="anthropic"):
    """Look up API key: env var > key file > config."""
    env_vars = {
        "anthropic": "ANTHROPIC_API_KEY",
        "openai": "OPENAI_API_KEY",
        "custom": "FIX_API_KEY",
    }
    key = os.environ.get(env_vars.get(key_type, ""), "")
    if not key:
        keyfile = os.path.join(CONFIG_DIR, f"{key_type}_key" if key_type != "anthropic" else "api_key")
        if os.path.exists(keyfile):
            with open(keyfile) as f:
                key = f.read().strip()
    return key


def resolve_backend(cfg, force_local=False):
    """Determine which backend to use.

    Priority: custom agent fn > explicit flag > env var > config > auto-detect
    Returns: (backend_name, call_fn_kwargs)
    """
    # Custom agent function from config (def agent(contract) in .fix.py)
    agent_fn = cfg.get("agent")
    if callable(agent_fn) and not force_local:
        return "custom", {"fn": agent_fn}

    if force_local:
        if ollama_available(cfg.get("ollama_url")):
            return "ollama", {"model": cfg.get("ollama_model"), "url": cfg.get("ollama_url")}
        raise RuntimeError("Ollama not running (--local requested)")

    # Check for custom OpenAI-compatible endpoint
    custom_url = os.environ.get("FIX_API_URL") or cfg.get("openai_api_url")
    custom_key = os.environ.get("FIX_API_KEY") or get_api_key("custom")
    custom_model = os.environ.get("FIX_MODEL") or cfg.get("openai_model")
    if custom_url and custom_key and custom_model:
        return "openai-compat", {"api_key": custom_key, "model": custom_model, "api_url": custom_url}

    # OpenAI
    openai_key = get_api_key("openai")
    if openai_key:
        return "openai", {"api_key": openai_key, "model": "gpt-4o-mini",
                          "api_url": "https://api.openai.com/v1"}

    # Claude (default cloud)
    claude_key = get_api_key("anthropic")
    if claude_key:
        return "claude", {"api_key": claude_key, "model": cfg.get("model", CLAUDE_MODEL),
                          "api_url": cfg.get("claude_api_url", CLAUDE_API_URL)}

    # Ollama fallback
    if ollama_available(cfg.get("ollama_url")):
        return "ollama", {"model": cfg.get("ollama_model"), "url": cfg.get("ollama_url")}

    raise RuntimeError("No LLM backend available. Set ANTHROPIC_API_KEY, OPENAI_API_KEY, or start Ollama.")


# --- Contract ---

def build_contract(command, stderr_text, env_info,
                   verify_spec=None, safe_mode=False, backend_name="",
                   attempt=0, prior_failures=None, root=None,
                   bounty=None, judge=None):
    """Build a contract object that both parties see and agree to."""
    # Verification terms
    if verify_spec is None:
        verification = {
            "method": "exit_code",
            "target": command,
            "criterion": "exit 0"
        }
    elif verify_spec == "human":
        verification = {
            "method": "human_judgment",
            "target": command,
            "criterion": "human approves the output"
        }
    elif verify_spec.startswith("contains "):
        match = re.match(r"contains\s+['\"](.+?)['\"]", verify_spec)
        verification = {
            "method": "output_match",
            "target": command,
            "criterion": f"stdout contains '{match.group(1)}'" if match else verify_spec
        }
    elif verify_spec.startswith("not contains "):
        match = re.match(r"not contains\s+['\"](.+?)['\"]", verify_spec)
        verification = {
            "method": "output_exclusion",
            "target": command,
            "criterion": f"output must not contain '{match.group(1)}'" if match else verify_spec
        }
    else:
        verification = {
            "method": "custom_command",
            "target": verify_spec,
            "criterion": "verification command exits 0"
        }

    contract = {
        "version": 1,
        "task": {
            "type": "fix_command",
            "command": command,
            "error": stderr_text[-1000:],
        },
        "environment": {
            "os": f"{env_info.get('distro', '')} ({env_info['os']} {env_info['release']})",
            "arch": env_info["machine"],
            "shell": env_info["shell"],
            "package_managers": env_info.get("package_managers", []),
        },
        "verification": verification,
        "terms": {
            "sandbox": safe_mode,
            "network": "package_installs_only" if safe_mode else "unrestricted",
            "max_attempts": MAX_FIX_ATTEMPTS,
            "current_attempt": attempt + 1,
            "rollback_on_failure": safe_mode,
            "root": os.path.realpath(root) if root else None,
        },
        "agent": {
            "backend": backend_name,
        },
    }

    if bounty:
        contract["escrow"] = {
            "bounty": bounty,
            "judge": "provided" if judge else "none",
            "terms": "Agent receives bounty on fulfilled contract. "
                     "On breach, bounty is retained by principal. "
                     + ("Disputes are resolved by a third-party judge." if judge else
                        "No dispute resolution — verification is final."),
        }

    if prior_failures:
        contract["prior_failures"] = [
            {"fix": fix, "result": err[:300]}
            for fix, err in prior_failures
        ]

    return contract


def display_contract(contract, status_fn):
    """Print the contract to the user's terminal."""
    v = contract["verification"]
    t = contract["terms"]
    cmd = contract["task"]["command"]

    # Measure widest line for the box
    lines = []
    lines.append(("Task", cmd))
    # Format verification nicely
    verify_str = v["criterion"]
    if v["method"] == "exit_code":
        verify_str = f"re-run command {C_DIM}\u2192{C_RESET} {verify_str}"
    elif v["method"] == "human_judgment":
        verify_str = f"human reviews output"
    elif v["method"] == "output_match":
        verify_str = v["criterion"]
    elif v["method"] == "output_exclusion":
        verify_str = v["criterion"]
    elif v["method"] == "custom_command":
        verify_str = f"run {C_DIM}\u2192{C_RESET} {v['target']}"
    lines.append(("Verify", verify_str))
    if t["sandbox"]:
        sandbox_parts = []
        sandbox_parts.append(f"isolated overlay")
        sandbox_parts.append(f"net: {t['network']}")
        if t["rollback_on_failure"]:
            sandbox_parts.append(f"rollback on breach")
        lines.append(("Sandbox", " \u00b7 ".join(sandbox_parts)))
    if t.get("root"):
        lines.append(("Root", t["root"]))
    if contract.get("escrow"):
        e = contract["escrow"]
        escrow_str = f"{C_GREEN}{e['bounty']}{C_RESET}"
        if e["judge"] != "none":
            escrow_str += f" {C_DIM}\u00b7{C_RESET} judge: {e['judge']}"
        lines.append(("Escrow", escrow_str))
    lines.append(("Attempt", f"{t['current_attempt']} of {t['max_attempts']}"))
    if contract.get("prior_failures"):
        n = len(contract["prior_failures"])
        lines.append(("History", f"{n} prior breach{'es' if n != 1 else ''}"))

    # Draw box
    print(file=sys.stderr)
    print(f"  {C_CYAN}\u250c\u2500 Contract \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500{C_RESET}", file=sys.stderr)
    for label, value in lines:
        print(f"  {C_CYAN}\u2502{C_RESET}  {C_DIM}{label:>8}{C_RESET}   {value}", file=sys.stderr)
    print(f"  {C_CYAN}\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500{C_RESET}", file=sys.stderr)


def build_prompt(command, stderr_text, env_info, contract, prior_failures=None):
    # Strip internal fields the agent doesn't need to see
    prompt_contract = {k: v for k, v in contract.items() if k != "agent"}
    contract_json = json.dumps(prompt_contract, indent=2)
    v = contract["verification"]
    t = contract["terms"]

    prompt = f"""FIX CONTRACT — BINDING AGREEMENT

You are an autonomous repair agent operating under the `fix` system.
A user's command has failed. You are being offered a contract to diagnose
and repair the failure. This contract is a binding agreement: if you accept,
you must deliver a fix that satisfies the verification terms below. Your fix
will be tested mechanically — there is no negotiation after acceptance.

=== PARTIES ===
PRINCIPAL (user): Owns the system described below. Wants the command to work.
AGENT (you):      Diagnose the failure. Propose a repair. Accept the terms.

=== CONTRACT ===
{contract_json}

=== OBLIGATIONS ===

1. ACCEPTANCE: By responding, you accept this contract. Set "accepted": true
   in your response to acknowledge the terms. If you cannot fix this, set
   "accepted": false and explain why in "explanation".

2. DELIVERABLE: Provide shell command(s) in the "fix" field that resolve the
   root cause of the failure. Commands must be idempotent and atomic where
   possible (chain with &&). Do not fix symptoms — fix causes.

3. VERIFICATION: After your fix is applied, the system will verify the result
   using the method specified in the contract:
   - Method: {v['method']}
   - Criterion: {v['criterion']}
   - Target: {v['target']}
   If verification fails, the contract is BREACHED. {'All filesystem changes are rolled back.' if t['rollback_on_failure'] else 'Changes persist but the fix is marked as failed.'}

4. CONSTRAINTS:
   - {'SANDBOXED: Your fix runs in an isolated overlay filesystem. Changes are only committed if verification passes.' if t['sandbox'] else 'DIRECT: Your fix runs directly on the system. Be careful.'}
   - Network: {t['network']}
   - Attempt {t['current_attempt']} of {t['max_attempts']}
   - Prefer the system package manager (apt/dnf/pacman with sudo)
   - Use pip install --break-system-packages if apt doesn't have the package
   - Keep it minimal. One fix, not a tutorial.

=== INVESTIGATION ===

Before proposing a fix, you may investigate the system. To run a read-only
command, output a line starting with INVESTIGATE: followed by the command.
Example:
    INVESTIGATE: python3 --version
    INVESTIGATE: cat foo.c
    INVESTIGATE: dpkg -l | grep libfoo

Only read-only commands are allowed (cat, ls, grep, pip list, dpkg, etc.).
{"Commands are jailed to root: " + t['root'] + ". Use relative paths. Absolute paths outside root will be blocked." if t.get('root') else ""}
The results will be appended and you will be re-prompted. When you have enough
information, respond with your JSON fix object. You may also skip investigation
and respond immediately if the error is obvious.

You may decline at any point — including after investigating — if you determine
the problem is beyond your ability to fix. Just respond with the JSON object
with "accepted": false and explain why.

=== RESPONSE FORMAT ===

When ready, respond with a JSON object (no markdown fences, no commentary outside it):

{{"accepted": true, "fix": "shell command(s)", "explanation": "one line why", "retry": true}}

"retry" indicates whether the original command should be re-run after the fix."""

    if prior_failures:
        prompt += "\n\n=== PRIOR BREACHES ===\n"
        prompt += "The following fixes were attempted and FAILED verification.\n"
        prompt += "Do NOT repeat them. Analyze why they failed and try a different approach.\n"
        for i, (fix, err) in enumerate(prior_failures, 1):
            prompt += f"\nAttempt {i}:\n  Fix: {fix}\n  Result: {err[:300]}\n"

    return prompt


def build_explain_prompt(command, stderr_text, env_info):
    return f"""A command failed. Explain what went wrong in 2-3 sentences.
Be specific and actionable. Don't suggest a fix, just explain the error.

COMMAND: {command}

ERROR:
{stderr_text[-2000:]}

SYSTEM: {env_info.get('distro', '')} ({env_info['os']}) {env_info['machine']}"""


def parse_llm_response(raw):
    text = raw.strip()
    if text.startswith("```"):
        text = "\n".join(text.split("\n")[1:])
        if text.endswith("```"):
            text = text[:-3]
        text = text.strip()
    if not text.startswith("{"):
        start = text.find("{")
        end = text.rfind("}") + 1
        if start >= 0 and end > start:
            text = text[start:end]
    return json.loads(text)


def _call_backend(prompt, backend_name, backend_kwargs, contract=None):
    """Single-shot call to a backend. Returns raw text."""
    if backend_name == "custom":
        fn = backend_kwargs["fn"]
        result = fn(contract or {})
        if isinstance(result, dict):
            return json.dumps(result)
        return result
    elif backend_name == "claude":
        return call_claude(prompt, **backend_kwargs)
    elif backend_name in ("openai", "openai-compat"):
        return call_openai(prompt, **backend_kwargs)
    elif backend_name == "ollama":
        return call_ollama(prompt, **backend_kwargs)
    raise RuntimeError(f"Unknown backend: {backend_name}")


def call_llm(prompt, backend_name, backend_kwargs, contract=None):
    """Call LLM with investigation loop. Any backend can investigate.

    If the response contains INVESTIGATE: <command> lines, we run each
    command, append the results to the prompt, and re-call. Up to
    MAX_INVESTIGATE_ROUNDS total rounds.
    """
    current_prompt = prompt
    root = contract.get("terms", {}).get("root") if contract else None

    for round_n in range(MAX_INVESTIGATE_ROUNDS + 1):
        raw = _call_backend(current_prompt, backend_name, backend_kwargs, contract)

        # Check for investigation requests
        commands = INVESTIGATE_RE.findall(raw)
        if not commands or round_n >= MAX_INVESTIGATE_ROUNDS:
            return raw

        # Run each investigation command, build results
        results = []
        for cmd in commands:
            cmd = cmd.strip()
            status(f"\U0001f50d", f"{C_DIM}{cmd}{C_RESET}")
            output = run_investigate_command(cmd, root=root)
            results.append(f"$ {cmd}\n{output}")

        # Re-prompt with investigation results appended
        investigation_block = "\n\n".join(results)
        current_prompt = (
            f"{current_prompt}\n\n"
            f"=== INVESTIGATION RESULTS ===\n"
            f"{investigation_block}\n\n"
            f"Continue investigating or respond with your JSON fix object."
        )

    return raw


# --- Shell History (fix !!) ---

def get_last_failed_command():
    """Get the last command from shell history.

    Reads bash/zsh history file. Falls back to HISTFILE env var.
    """
    histfile = os.environ.get("HISTFILE")
    if not histfile:
        shell = os.environ.get("SHELL", "")
        if "zsh" in shell:
            histfile = os.path.expanduser("~/.zsh_history")
        else:
            histfile = os.path.expanduser("~/.bash_history")

    if not os.path.exists(histfile):
        return None

    try:
        with open(histfile, "rb") as f:
            # Read last few KB (history can be huge)
            f.seek(0, 2)
            size = f.tell()
            f.seek(max(0, size - 8192))
            data = f.read().decode("utf-8", errors="replace")

        lines = data.strip().splitlines()
        # Filter out 'fix' commands and empty lines
        for line in reversed(lines):
            line = line.strip()
            # zsh history format: ": timestamp:0;command"
            if line.startswith(":") and ";" in line:
                line = line.split(";", 1)[1]
            if line and not line.startswith("fix ") and line != "fix" and line != "claude":
                return line
    except Exception:
        pass
    return None


# --- Sandbox ---

ALLOWED_PATHS = {
    "python-pkg": ["/usr/lib/python*", "/usr/local/lib/python*", "/usr/share/python*",
                   "/var/lib/dpkg", "/var/cache/apt", "/var/lib/apt", "/etc/apt"],
    "system-pkg": ["/usr/bin/*", "/usr/lib/*", "/usr/share/*", "/var/lib/dpkg*",
                   "/var/cache/apt*", "/var/cache/debconf*", "/var/lib/apt*",
                   "/var/log/dpkg*", "/var/log/apt*", "/var/lib/update-notifier*",
                   "/etc/apt*", "/etc/ld.so.*"],
    "compiler": ["/usr/include/*", "/usr/lib/gcc/*", "/usr/bin/gcc*", "/usr/bin/cc*", "/tmp/*"],
}
DEFAULT_ALLOWED = [p for paths in ALLOWED_PATHS.values() for p in paths]


class Sandbox:
    DEFAULT_HIDDEN = [".ssh", ".gnupg", ".fix", ".config/gh", ".netrc", ".aws",
                      ".azure", ".kube", ".docker", ".gitconfig", ".bash_history",
                      ".python_history"]

    def __init__(self, allowed_paths=None, hidden_paths=None, visible_paths=None, user_home=None):
        self.workdir = None
        self.overlay_dirs = []
        self.allowed_paths = allowed_paths or DEFAULT_ALLOWED
        self.user_home = user_home or self._detect_home()
        if hidden_paths:
            self.hidden_paths = [self._resolve_path(p) for p in hidden_paths]
        else:
            self.hidden_paths = [os.path.join(self.user_home, p) for p in self.DEFAULT_HIDDEN]
        self.visible_paths = [self._resolve_path(p) for p in (visible_paths or [])]
        self._empty_dir = None

    def _detect_home(self):
        sudo_user = os.environ.get("SUDO_USER")
        if sudo_user:
            import pwd
            return pwd.getpwnam(sudo_user).pw_dir
        return os.path.expanduser("~")

    def _resolve_path(self, p):
        if p.startswith("~/"):
            return os.path.join(self.user_home, p[2:])
        return os.path.expanduser(p)

    def _sudo(self, cmd):
        password = os.environ.get("SUDO_PASSWORD", "")
        if password:
            return subprocess.run(f"echo '{password}' | sudo -S {cmd}", shell=True,
                                  capture_output=True, text=True)
        return subprocess.run(f"sudo {cmd}", shell=True, capture_output=True, text=True)

    def _resolve_hidden_paths(self):
        if self.visible_paths:
            home = self.user_home
            hide = []
            for entry in os.listdir(home):
                full = os.path.join(home, entry)
                if not any(full == v or full.startswith(v + "/") for v in self.visible_paths):
                    hide.append(full)
            return hide
        return [p for p in self.hidden_paths if os.path.exists(p)]

    def setup(self):
        r = self._sudo("mktemp -d /run/fix-sandbox-XXXXXXXX")
        if r.returncode != 0:
            raise RuntimeError(f"Failed to create sandbox dir: {r.stderr}")
        self.workdir = r.stdout.strip()
        self._empty_dir = os.path.join(self.workdir, "_empty")
        self._sudo(f"mkdir -p {self._empty_dir}")

        targets = ["/usr", "/var", "/etc", "/home", "/tmp"]
        for target in targets:
            if not os.path.isdir(target):
                continue
            name = target.strip("/").replace("/", "_")
            upper = os.path.join(self.workdir, f"{name}_upper")
            work = os.path.join(self.workdir, f"{name}_work")
            merged = os.path.join(self.workdir, f"{name}_merged")
            self._sudo(f"mkdir -p {upper} {work} {merged}")
            self.overlay_dirs.append((target, upper, work, merged))

        for target, upper, work, merged in self.overlay_dirs:
            r = self._sudo(f"mount -t overlay overlay "
                           f"-o lowerdir={target},upperdir={upper},workdir={work} {merged}")
            if r.returncode != 0:
                raise RuntimeError(f"Failed to mount overlay for {target}: {r.stderr}")

    def run_in_sandbox(self, command, network=False):
        bind_cmds = []
        for target, upper, work, merged in self.overlay_dirs:
            bind_cmds.append(f"mount --bind {merged} {target}")

        if self.visible_paths:
            home_merged = None
            for target, upper, work, merged in self.overlay_dirs:
                if self.user_home.startswith(target):
                    home_merged = merged
                    break
            bind_cmds.append(f"mount -t tmpfs tmpfs {self.user_home}")
            for vpath in self.visible_paths:
                if os.path.exists(vpath):
                    rel = os.path.relpath(vpath, self.user_home)
                    mountpoint = os.path.join(self.user_home, rel)
                    if home_merged:
                        target_for_home = [t for t, u, w, m in self.overlay_dirs if m == home_merged][0]
                        source = os.path.join(home_merged, os.path.relpath(vpath, target_for_home))
                    else:
                        source = vpath
                    if os.path.isdir(vpath):
                        bind_cmds.append(f"mkdir -p {mountpoint}")
                    else:
                        bind_cmds.append(f"mkdir -p {os.path.dirname(mountpoint)} && touch {mountpoint}")
                    bind_cmds.append(f"mount --bind {source} {mountpoint}")
        else:
            for hidden in self._resolve_hidden_paths():
                if os.path.isdir(hidden):
                    bind_cmds.append(f"mount --bind {self._empty_dir} {hidden}")
                elif os.path.exists(hidden):
                    bind_cmds.append(f"mount --bind /dev/null {hidden}")

        safe_cmd = command.replace("'", "'\\''")
        script = " && ".join(bind_cmds + [safe_cmd])
        ns_flags = "--mount" + ("" if network else " --net")
        full_cmd = f"unshare {ns_flags} -- bash -c '{script}'"

        password = os.environ.get("SUDO_PASSWORD", "")
        if password:
            full_cmd = f"echo '{password}' | sudo -S {full_cmd}"
        else:
            full_cmd = f"sudo {full_cmd}"

        return subprocess.run(full_cmd, shell=True, capture_output=True, text=True, timeout=120)

    def get_diff(self):
        changed = []
        for target, upper, work, merged in self.overlay_dirs:
            r = self._sudo(f"find {upper} -type f -printf '%s %p\\n'")
            if r.returncode != 0 or not r.stdout.strip():
                continue
            for line in r.stdout.strip().split("\n"):
                parts = line.split(" ", 1)
                if len(parts) != 2:
                    continue
                size, overlay_path = int(parts[0]), parts[1]
                rel = os.path.relpath(overlay_path, upper)
                real_path = os.path.join(target, rel)
                changed.append({
                    "path": real_path, "overlay_path": overlay_path,
                    "size": size, "is_delete": os.path.basename(overlay_path).startswith(".wh."),
                })
        return changed

    def check_allowlist(self, changed_files):
        import fnmatch
        allowed, violations = [], []
        for entry in changed_files:
            path = entry["path"]
            is_ok = False
            for pattern in self.allowed_paths:
                if fnmatch.fnmatch(path, pattern):
                    is_ok = True
                    break
                if path.startswith(pattern.rstrip("*")):
                    is_ok = True
                    break
            (allowed if is_ok else violations).append(entry)
        return allowed, violations

    def commit(self):
        for target, upper, work, merged in self.overlay_dirs:
            check = self._sudo(f"find {upper} -mindepth 1 -maxdepth 1 | head -1")
            if check.stdout.strip():
                r = self._sudo(f"rsync -a {upper}/ {target}/")
                if r.returncode != 0:
                    raise RuntimeError(f"Failed to merge {upper} -> {target}: {r.stderr}")

    def rollback(self):
        pass

    def cleanup(self):
        if not self.workdir:
            return
        for target, upper, work, merged in self.overlay_dirs:
            self._sudo(f"umount {merged} 2>/dev/null")
        self._sudo(f"rm -rf {self.workdir}")
        self.workdir = None


def format_size(n):
    for unit in ("B", "KB", "MB", "GB"):
        if n < 1024:
            return f"{n:.0f}{unit}"
        n /= 1024
    return f"{n:.1f}TB"


def run_sandboxed_fix(fix_cmd, original_cmd, verify_spec, cfg, status_fn):
    """Transactional fix: snapshot -> fix -> verify -> commit/rollback."""
    hidden = None
    visible = None
    if os.environ.get("FIX_HIDDEN_PATHS"):
        hidden = Sandbox.DEFAULT_HIDDEN + json.loads(os.environ["FIX_HIDDEN_PATHS"])
    if os.environ.get("FIX_VISIBLE_PATHS"):
        visible = json.loads(os.environ["FIX_VISIBLE_PATHS"])

    sandbox = Sandbox(hidden_paths=hidden, visible_paths=visible)
    try:
        status_fn(f"{C_BLUE}#{C_RESET}", "Creating filesystem snapshot...")
        sandbox.setup()

        hidden_list = sandbox._resolve_hidden_paths()
        if hidden_list:
            mode = "whitelist" if sandbox.visible_paths else "blacklist"
            status_fn(f"{C_DIM}#{C_RESET}", f"Visibility ({mode}): hiding {len(hidden_list)} path(s)")

        needs_net = any(pkg_cmd in fix_cmd for pkg_cmd in
                        ["apt ", "apt-get ", "pip ", "pip3 ", "npm ", "cargo ",
                         "dnf ", "pacman ", "wget ", "curl ", "git clone"])
        status_fn(f"{C_YELLOW}*{C_RESET}",
                  f"[sandbox] Running fix (net: {'yes' if needs_net else 'no'}): {fix_cmd[:60]}")
        fix_result = sandbox.run_in_sandbox(fix_cmd, network=needs_net)
        if fix_result.returncode != 0:
            status_fn(f"{C_RED}!{C_RESET}", f"[sandbox] Fix failed: {fix_result.stderr[:100]}")
            sandbox.rollback()
            return False, fix_result.stderr, ""

        # Diff audit
        changed = sandbox.get_diff()
        if changed:
            status_fn(f"{C_BLUE}#{C_RESET}", f"Diff audit: {len(changed)} file(s) modified")
            for entry in changed[:20]:
                icon = "-" if entry["is_delete"] else "+"
                status_fn(f"{C_DIM} {C_RESET}", f"  {icon} {entry['path']} ({format_size(entry['size'])})")

        # Allowlist check
        allowed, violations = sandbox.check_allowlist(changed)
        if violations:
            status_fn(f"{C_RED}!{C_RESET}", f"SECURITY: {len(violations)} file(s) outside allowlist!")
            for v in violations[:10]:
                status_fn(f"{C_RED}!{C_RESET}", f"  BLOCKED: {v['path']}")
            sandbox.rollback()
            return False, fix_result.stdout, "ALLOWLIST_VIOLATION"

        # Verification runs inside sandbox
        verifier = SandboxVerifier(verify_spec, original_cmd, sandbox)
        success, explanation = verifier.verify(fix_result)
        status_fn(f"{C_GREEN if success else C_RED}{'+'  if success else '!'}{C_RESET}", explanation)

        if success:
            status_fn(f"{C_GREEN}+{C_RESET}", "Committing changes...")
            sandbox.commit()
            return True, fix_result.stdout, ""
        else:
            status_fn(f"{C_RED}!{C_RESET}", "Rolling back (system unchanged).")
            sandbox.rollback()
            return False, fix_result.stdout, explanation

    except Exception as e:
        status_fn(f"{C_RED}!{C_RESET}", f"Sandbox error: {e}")
        sandbox.rollback()
        return False, "", str(e)
    finally:
        sandbox.cleanup()


# --- Main Loop ---

def run_fix(command, cfg, verify_spec=None, explain_only=False, dry_run=False,
            force_local=False, safe_mode=False, auto_yes=False):

    # Use project config verify as default if no --verify flag given
    if verify_spec is None and cfg.get("verify"):
        verify_spec = cfg["verify"]

    # Run the command
    print(file=sys.stderr)
    status(f"{C_BLUE}\u25b8{C_RESET}", f"{C_BOLD}{command}{C_RESET}")
    proc = subprocess.run(command, shell=True, capture_output=True, text=True)

    if proc.stdout:
        sys.stdout.write(proc.stdout)
    if proc.returncode == 0:
        if proc.stderr:
            sys.stderr.write(proc.stderr)
        return 0

    sys.stderr.write(proc.stderr)
    status(f"{C_RED}\u2717{C_RESET}", f"Exited {proc.returncode}")

    if not proc.stderr.strip():
        status(f"{C_DIM}?{C_RESET}", "No stderr to analyze.")
        return proc.returncode

    env_info = get_env_fingerprint()

    # Resolve backend
    try:
        backend_name, backend_kwargs = resolve_backend(cfg, force_local)
    except RuntimeError as e:
        status(f"{C_RED}!{C_RESET}", str(e))
        return proc.returncode

    # --explain: just explain the error
    if explain_only:
        prompt = build_explain_prompt(command, proc.stderr, env_info)
        try:
            raw = call_llm(prompt, backend_name, backend_kwargs)
        except RuntimeError as e:
            status(f"{C_RED}!{C_RESET}", str(e))
            return proc.returncode
        print(f"\n{raw.strip()}\n")
        return proc.returncode

    status(f"{C_YELLOW}\u25cb{C_RESET}", f"Dispatching to agent...")

    # Multi-attempt: try up to MAX_FIX_ATTEMPTS, feeding failures back
    prior_failures = []

    for attempt in range(MAX_FIX_ATTEMPTS):
        # Build contract -- the shared agreement between user and agent
        contract = build_contract(
            command, proc.stderr, env_info,
            verify_spec=verify_spec, safe_mode=safe_mode,
            backend_name=backend_name, attempt=attempt,
            prior_failures=prior_failures or None,
            root=cfg.get("root"),
            bounty=cfg.get("bounty"),
            judge=cfg.get("judge"),
        )
        display_contract(contract, status)

        prompt = build_prompt(command, proc.stderr, env_info, contract,
                              prior_failures or None)

        # Parse LLM response (retry on bad JSON)
        result = None
        for json_retry in range(3):
            try:
                raw = call_llm(prompt, backend_name, backend_kwargs, contract=contract)
                result = parse_llm_response(raw)
                break
            except json.JSONDecodeError:
                if json_retry < 2:
                    status(f"{C_DIM}~{C_RESET}", "Bad response, retrying...")
                    continue
                status(f"{C_RED}!{C_RESET}", f"Could not parse fix from {backend_name}.")
                return proc.returncode
            except RuntimeError as e:
                status(f"{C_RED}!{C_RESET}", str(e))
                return proc.returncode

        # Agent's response to the contract
        accepted = result.get("accepted")
        decline_reason = result.get("explanation", "no reason given")

        if accepted is False:
            print(file=sys.stderr)
            status(f"{C_RED}\u2718{C_RESET}", f"Agent {C_RED}DECLINED{C_RESET}: {C_ITALIC}{decline_reason}{C_RESET}")
            return proc.returncode
        elif accepted is True:
            status(f"{C_GREEN}\u2714{C_RESET}", f"Agent {C_GREEN}accepted{C_RESET}")
        else:
            status(f"{C_DIM}\u2714{C_RESET}", f"{C_DIM}Agent accepted (implicit){C_RESET}")

        fix_cmd = result["fix"]
        if isinstance(fix_cmd, list):
            fix_cmd = " && ".join(fix_cmd)
        explanation = result.get("explanation", "")

        # Record agent's response in the contract
        contract["agent"]["accepted"] = True
        contract["agent"]["fix"] = fix_cmd
        contract["agent"]["explanation"] = explanation

        attempt_label = f" (attempt {attempt + 1}/{MAX_FIX_ATTEMPTS})" if attempt > 0 else ""
        print(file=sys.stderr)
        status(f"{C_GREEN}\u25c6{C_RESET}", f"Fix{attempt_label}: {C_BOLD}{fix_cmd}{C_RESET}")
        if explanation:
            status(f" ", f"{C_DIM}{C_ITALIC}{explanation}{C_RESET}")

        # --dry-run: show fix and contract, stop
        if dry_run:
            print(file=sys.stderr)
            return proc.returncode

        if not auto_yes and sys.stdin.isatty():
            print(file=sys.stderr)
            confirm = input(f"  ?  Apply this fix? [Y/n] ")
            if confirm.strip().lower() == "n":
                return proc.returncode

        # Apply fix
        rc = apply_fix(fix_cmd, command, verify_spec, safe_mode, cfg, contract)

        if rc == 0:
            return 0

        # Fix didn't work -- if we have more attempts, feed failure context back
        if attempt < MAX_FIX_ATTEMPTS - 1:
            status(f"{C_YELLOW}\u21bb{C_RESET}", f"Attempt {attempt + 1} breached. Retrying with context...")
            verify_proc = subprocess.run(command, shell=True, capture_output=True, text=True)
            prior_failures.append((fix_cmd, verify_proc.stderr[:500] if verify_proc.stderr else "exit non-zero"))
            continue

    return 1


def apply_fix(fix_cmd, original_cmd, verify_spec, safe_mode, cfg, contract=None):
    """Apply a fix and verify it. Returns exit code."""

    if safe_mode:
        status(f"{C_BLUE}\u25b8{C_RESET}", "Executing in sandbox...")
        success, fix_out, verify_out = run_sandboxed_fix(
            fix_cmd, original_cmd, verify_spec, cfg, status)
        print(file=sys.stderr)
        explanation = verify_out or ("Changes committed" if success else "System unchanged")
    else:
        # Direct execution
        status(f"{C_BLUE}\u25b8{C_RESET}", "Applying fix...")
        fix_proc = subprocess.run(fix_cmd, shell=True, capture_output=True, text=True)

        if fix_proc.returncode != 0:
            status(f"{C_RED}\u2717{C_RESET}", f"Fix command failed: {fix_proc.stderr[:100]}")
            return fix_proc.returncode

        # Verify
        verifier = Verifier(verify_spec, original_cmd)
        success, explanation = verifier.verify(fix_proc)
        print(file=sys.stderr)

    # Dispute resolution: if verification failed and a judge is configured, appeal
    if not success and contract and contract.get("escrow"):
        judge_fn = cfg.get("judge")
        if callable(judge_fn):
            outcome = {
                "fix": fix_cmd,
                "success": False,
                "explanation": explanation,
            }
            status(f"{C_YELLOW}\u2696{C_RESET}", "Verification failed. Appealing to judge...")
            try:
                verdict = judge_fn(contract, outcome)
                if isinstance(verdict, dict):
                    ruling = verdict.get("ruling", "breach")
                    reason = verdict.get("reason", "no reason given")
                    if ruling == "fulfilled":
                        status(f"{C_GREEN}\u2696{C_RESET}",
                               f"Judge {C_GREEN}overruled{C_RESET}: {C_ITALIC}{reason}{C_RESET}")
                        success = True
                        explanation = f"Judge: {reason}"
                    else:
                        status(f"{C_RED}\u2696{C_RESET}",
                               f"Judge {C_RED}upheld breach{C_RESET}: {C_ITALIC}{reason}{C_RESET}")
            except Exception as e:
                status(f"{C_RED}!{C_RESET}", f"Judge error: {e}")

    if success:
        status(f"{C_GREEN}\u2714{C_RESET}", f"{C_GREEN}Contract fulfilled.{C_RESET} {explanation}")
        if contract and contract.get("escrow"):
            status(f"{C_GREEN}${C_RESET}",
                   f"Escrow: {contract['escrow']['bounty']} released to agent")
    else:
        msg = f"{C_RED}Contract breached.{C_RESET} {explanation}"
        if safe_mode:
            msg += " System unchanged."
        status(f"{C_RED}\u2718{C_RESET}", msg)
        if contract and contract.get("escrow"):
            status(f"{C_DIM}${C_RESET}",
                   f"Escrow: {contract['escrow']['bounty']} retained by principal")

    return 0 if success else 1


# --- CLI ---

def main():
    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
        print(__doc__.strip())
        return

    cfg = load_config()

    # Subcommands
    if sys.argv[1] == "init":
        generate_config()
        return
    if sys.argv[1] == "shell":
        if len(sys.argv) > 2 and sys.argv[2] == "--install":
            shell_install()
        else:
            shell_hook()
        return

    # Parse flags
    args = sys.argv[1:]
    flags = {
        "auto_yes": False,
        "force_local": False,
        "safe_mode": cfg.get("safe_mode", False),
        "explain_only": False,
        "dry_run": False,
        "verify_spec": None,
    }
    hidden_extra = []
    visible_only = []
    filtered_args = []

    i = 0
    while i < len(args):
        a = args[i]
        if a in ("-y", "--yes"):
            flags["auto_yes"] = True
        elif a in ("--local", "--ollama"):
            flags["force_local"] = True
        elif a == "--safe":
            flags["safe_mode"] = True
        elif a == "--explain":
            flags["explain_only"] = True
        elif a == "--dry-run":
            flags["dry_run"] = True
        elif a.startswith("--verify="):
            flags["verify_spec"] = a[len("--verify="):]
        elif a == "--verify" and i + 1 < len(args):
            i += 1
            flags["verify_spec"] = args[i]
        elif a in ("-m", "--model") and i + 1 < len(args):
            i += 1
            cfg["model"] = args[i]
            cfg["ollama_model"] = args[i]
        elif a == "--root" and i + 1 < len(args):
            i += 1
            cfg["root"] = args[i]
        elif a == "--hide" and i + 1 < len(args):
            i += 1
            hidden_extra.append(args[i])
        elif a == "--visible" and i + 1 < len(args):
            i += 1
            visible_only.append(args[i])
        else:
            filtered_args.append(a)
        i += 1

    if hidden_extra:
        os.environ["FIX_HIDDEN_PATHS"] = json.dumps(hidden_extra)
    if visible_only:
        os.environ["FIX_VISIBLE_PATHS"] = json.dumps(visible_only)

    # Handle fix it / fix !!
    if filtered_args in (["it"], ["!!"]):
        last_cmd = os.environ.get("FIX_LAST_COMMAND") or get_last_failed_command()
        if not last_cmd:
            status(f"{C_RED}!{C_RESET}", "Could not find last command in shell history.")
            print(f"\n  {C_DIM}fix needs a shell hook to capture the last command.{C_RESET}", file=sys.stderr)
            if sys.stdin.isatty():
                if shell_install():
                    print(f"\n  {C_DIM}Run your command again, then try fix it.{C_RESET}", file=sys.stderr)
            else:
                name = _detect_shell()
                print(f"  {C_DIM}Run: fix shell --install{C_RESET}", file=sys.stderr)
            sys.exit(1)
        status(f"{C_DIM}\u25b8{C_RESET}", f"Last command: {C_BOLD}{last_cmd}{C_RESET}")
        command = last_cmd
    elif not filtered_args:
        print(__doc__.strip())
        return
    else:
        command = " ".join(filtered_args)

    sys.exit(run_fix(command, cfg, **flags))


if __name__ == "__main__":
    main()
